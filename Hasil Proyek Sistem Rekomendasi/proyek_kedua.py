# -*- coding: utf-8 -*-
"""Proyek Kedua.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1KGrbQSiKjfDb6EonVeablYYjKAFQESJQ

# Sitem Rekomendasi

## Data Loading
"""

import os
os.environ['KAGGLE_USERNAME'] = "ichsannuriman"
os.environ['KAGGLE_KEY'] = "e20dd538318e3a23d0bbfdf1e29fbdb8"

!kaggle datasets download -d CooperUnion/anime-recommendations-database

!unzip -q anime-recommendations-database.zip -d .

import pandas as pd
import numpy as np 
from zipfile import ZipFile
import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers
from pathlib import Path
import matplotlib.pyplot as plt
from sklearn.feature_extraction.text import TfidfVectorizer

"""## Data Understanding"""

anime = pd.read_csv('/content/anime.csv')
rating = pd.read_csv('/content/rating.csv')

print('Jumlah data nama anime: ', len(anime.name.unique()))
print('Jumlah data user yang memberi rating: ', len(rating.user_id.unique()))

"""## Univariate Analysis and Data Preparation

### Informasi Dataframe anime.csv
"""

anime.info()

print('Banyak anime: ', len(anime.name.unique()))
print('Genre anime: ', anime.genre.unique())

anime

"""#### Mengatasi Missing Value"""

anime.isnull().sum()

anime =  anime.dropna()
anime.isnull().sum()

"""### Informasi Dataframe rating.csv"""

rating.info()

#Hanya mengambil 2000 jumlah data
rating = rating.drop(range(2000, 7813737))
rating

rating["rating"].replace({-1: np.nan}, inplace=True)
rating.head()

rating = rating.dropna(axis = 0, how ='any')
rating

rating.describe()

print('Jumlah user_id: ', len(rating.user_id.unique()))
print('Jumlah anime_id: ', len(rating.anime_id.unique()))
print('Jumlah data rating: ', len(rating))

"""## Content Based Filtering

### TF-IDF Vectorizer
"""

tf = TfidfVectorizer()

tf.fit(anime['genre']) 

tf.get_feature_names()

tfidf_matrix = tf.fit_transform(anime['genre']) 

tfidf_matrix.shape

tfidf_matrix.todense()

pd.DataFrame(
    tfidf_matrix.todense(), 
    columns=tf.get_feature_names(),
    index=anime.name
).sample(22, axis=1).sample(10, axis=0)

"""### Cosine Similarity"""

from sklearn.metrics.pairwise import cosine_similarity

cosine_sim = cosine_similarity(tfidf_matrix) 
cosine_sim

cosine_sim_df = pd.DataFrame(cosine_sim, index=anime['name'], columns=anime['name'])
print('Shape:', cosine_sim_df.shape)

cosine_sim_df.sample(5, axis=1).sample(10, axis=0)

"""### Fungsi Rekomendasi"""

import tensorflow as tf

def anime_recommendations(nama_anime, similarity_data=cosine_sim_df, items=anime[['name', 'genre']], k=5):
    
    index = similarity_data.loc[:,nama_anime].to_numpy().argpartition(
        range(-1, -k, -1))
    
    closest = similarity_data.columns[index[-1:-(k+2):-1]]
    
    closest = closest.drop(nama_anime, errors='ignore')
 
    return pd.DataFrame(closest).merge(items).head(k)

"""### Uji Coba"""

anime[anime.name.eq('Kimi no Na wa.')]

result = anime_recommendations('Kimi no Na wa.')
result

a = 0

for row in result.itertuples():
  if (row.genre == 'Drama, Romance, School, Supernatural'):
    a += 1

precision = (a/5)*100
print("The precision of the model is {}%".format(precision))

anime_recommendations('Steins;Gate')

"""## Collaborative Based Filtering

### Menyiapkan Tabel Rating
"""

df = rating
df

"""#### Encoding"""

user_ids = df['user_id'].unique().tolist()
print('list user_id: ', user_ids)

user_to_user_encoded = {x: i for i, x in enumerate(user_ids)}
print('encoded user_id : ', user_to_user_encoded)

user_encoded_to_user = {i: x for i, x in enumerate(user_ids)}
print('encoded angka ke user_id: ', user_encoded_to_user)

anime_ids = df['anime_id'].unique().tolist()

anime_to_anime_encoded = {x: i for i, x in enumerate(anime_ids)}

anime_encoded_to_anime = {i: x for i, x in enumerate(anime_ids)}

"""#### Memetakan user_id dan anime_id"""

df['user'] = df['user_id'].map(user_to_user_encoded)

df['anime'] = df['anime_id'].map(anime_to_anime_encoded)

"""#### Mengecek jumlah user, jumlah resto, rating terkecil, dan rating terbesar"""

num_users = len(user_to_user_encoded)
print(num_users)

num_anime = len(anime_encoded_to_anime)
print(num_anime)

min_rating = min(df['rating'])

max_rating = max(df['rating'])
 
print('Number of User: {}, Number of Anime: {}, Min Rating: {}, Max Rating: {}'.format(
    num_users, num_anime, min_rating, max_rating
))

"""#### Mengacak Data"""

df = df.sample(frac=1, random_state=42)
df

"""### Train-Test Split"""

x = df[['user', 'anime']].values

y = df['rating'].apply(lambda x: (x - min_rating) / (max_rating - min_rating)).values

train_indices = int(0.8 * df.shape[0])
x_train, x_val, y_train, y_val = (
    x[:train_indices],
    x[train_indices:],
    y[:train_indices],
    y[train_indices:]
)
 
print(x, y)

"""### Fungsi Rekomendasi"""

class RecommenderNet(tf.keras.Model):

  def __init__(self, num_users, num_anime, embedding_size, **kwargs):
    super(RecommenderNet, self).__init__(**kwargs)
    self.num_users = num_users
    self.num_anime = num_anime
    self.embedding_size = embedding_size
    self.user_embedding = layers.Embedding(
        num_users,
        embedding_size,
        embeddings_initializer = 'he_normal',
        embeddings_regularizer = keras.regularizers.l2(1e-6)
    )
    self.user_bias = layers.Embedding(num_users, 1)
    self.anime_embedding = layers.Embedding(
        num_anime,
        embedding_size,
        embeddings_initializer = 'he_normal',
        embeddings_regularizer = keras.regularizers.l2(1e-6)
    )
    self.anime_bias = layers.Embedding(num_anime, 1)
 
  def call(self, inputs):
    user_vector = self.user_embedding(inputs[:,0])
    user_bias = self.user_bias(inputs[:, 0])
    anime_vector = self.anime_embedding(inputs[:, 1])
    anime_bias = self.anime_bias(inputs[:, 1])
 
    dot_user_anime = tf.tensordot(user_vector, anime_vector, 2) 
 
    x = dot_user_anime + user_bias + anime_bias
    
    return tf.nn.sigmoid(x)

"""### Compile Model"""

model = RecommenderNet(num_users, num_anime, 50)
 
model.compile(
    loss = tf.keras.losses.BinaryCrossentropy(),
    optimizer = keras.optimizers.Adam(learning_rate=0.001),
    metrics=[tf.keras.metrics.RootMeanSquaredError()]
)

"""### Training Model"""

history = model.fit(
    x = x_train,
    y = y_train,
    batch_size = 8,
    epochs = 100,
    validation_data = (x_val, y_val)
)

"""### Visualisasi Metrik"""

plt.plot(history.history['root_mean_squared_error'])
plt.plot(history.history['val_root_mean_squared_error'])
plt.title('model_metrics')
plt.ylabel('root_mean_squared_error')
plt.xlabel('epoch')
plt.legend(['train', 'test'], loc='upper left')
plt.show()

"""### Mendapatkan Rekomendasi Resto"""

anime_df = anime
df = rating

userID = df.user_id.sample(1).iloc[0]
anime_watched_by_user = df[df.user_id == userID]
 
anime_not_watched = anime_df[~anime_df['anime_id'].isin(anime_watched_by_user.anime_id.values)]['anime_id'] 
anime_not_watched = list(
    set(anime_not_watched)
    .intersection(set(anime_to_anime_encoded.keys()))
)
 
anime_not_watched = [[anime_to_anime_encoded.get(x)] for x in anime_not_watched]
user_encoder = user_to_user_encoded.get(userID)
user_anime_array = np.hstack(
    ([[user_encoder]] * len(anime_not_watched), anime_not_watched)
)

from tensorflow import keras

ratings = model.predict(user_anime_array).flatten()
 
top_ratings_indices = ratings.argsort()[-10:][::-1]
recommended_anime_ids = [
    anime_encoded_to_anime.get(anime_not_watched[x][0]) for x in top_ratings_indices
]
 
print('Showing recommendations for users: {}'.format(userID))
print('===' * 9)
print('Anime with high ratings from user')
print('----' * 8)
 
top_anime_user = (
    anime_watched_by_user.sort_values(
        by = 'rating',
        ascending=False
    )
    .head(5)
    .anime_id.values
)
 
anime_df_rows = anime_df[anime_df['anime_id'].isin(top_anime_user)]
for row in anime_df_rows.itertuples():
    print(row.name, ':', row.genre)
 
print('----' * 8)
print('Top 10 anime recommendation')
print('----' * 8)
 
recommended_anime = anime_df[anime_df['anime_id'].isin(recommended_anime_ids)]
for row in recommended_anime.itertuples():
    print(row.name, ':', row.genre)